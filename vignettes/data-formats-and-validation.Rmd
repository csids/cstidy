---
title: "Data formats and validation"
author: "Richard Aubrey White"
date: "2022-01-19"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data formats and validation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r echo=FALSE, include=FALSE}
library(data.table)
library(magrittr)
```

## Style

**Language**

English is the primary language for our code.

Names that are abbreviations or in Norwegian are kept as they are: data sources such as `msis, dar, sysvak, normomo`.

**Capital letters**

Capital letters are to be avoided whenever possible. This is also the case in filenames (e.g. `data.rds` is preferred to `data.RDS`)

**snake_case or camelCase?**

Use snake_case.

**Timestamping of file names**

In results (e.g. reports), an indicator of time when the files are created are necessary. It allows us to find which one is the most recent version of files with the same names, and it allows easy tracking of an Airflow error. 

e.g. `Epidemiologisk_situasjonsrapport_2021-05-31_0659.docx` for a report generated on May 31, 2021 06:59 AM. 

## Ordering of variables

Sometimes variables need to be ordered. Variables should be ordered as follows:

- time
- location
- age
- sex

e.g. A database table could be called `msis_by_time_location_age_sex` or a filename could be called `2020_oslo_05-10_male.xlsx`

## Time

Time functions can be obtained from [spltime](/spltime). Missing time data should be coded as `NA_character_`.

```{r echo=FALSE, results='asis'}
d <- rbind(
  data.frame(
    granularity_time = "day",
    class = "Date",
    fn = "as.Date",
    example = "2021-12-31"
  ),
  data.frame(
    granularity_time = "isoweek (numeric)",
    class = "numeric",
    fn = "spltime::isoweek_n",
    example = "1"
  ),
  data.frame(
    granularity_time = "isoweek (character)",
    class = "character",
    fn = "spltime::isoweek_c",
    example = "\"01\""
  ),
  data.frame(
    granularity_time = "isoyear (numeric)",
    class = "character",
    fn = "spltime::isoyear_n",
    example = "2021"
  ),
  data.frame(
    granularity_time = "isoyear (character)",
    class = "character",
    fn = "spltime::isoyear_c",
    example = "\"2021\""
  ),
  data.frame(
    granularity_time = "isoyearweek",
    class = "character",
    fn = "spltime::isoyearweek_c",
    example = "\"2021-01\""
  ),
  data.frame(
    granularity_time = "event_*_date1_to_date2",
    class = "character",
    fn = "as.character",
    example = "\"event_covid19_norway_vaccination_2020_12_02_to_9999_99_99\", \"event_covid19_norway_2020_02_21_to_9999_99_99\""
  )
)

gt::gt(d) %>%
  gt::tab_options(
    table.width = "1100px"
  ) %>%
  gt::tab_header(title = "Valid times in the splverse format") %>%
  gt::cols_label(
    granularity_time = "Time (Granularity)",
    class = "Class",
    fn = "Function",
    example = "Example(s)"
  ) %>%
  gt::cols_width(
    granularity_time ~ "20%",
    class ~ "15%",
    fn ~ "20%",
    example ~ "55%"
  ) %>%
  gt::tab_style(
    style = list(
      gt::cell_text(decorate = "line-through")
      ),
    locations = gt::cells_body(
      columns = gt::everything(),
      rows = stringr::str_detect(granularity_time, "character")
    )
  ) %>%
  gt::tab_footnote(
    footnote = "isoweek (numeric) is used when it is a standalone variable.",
    locations = gt::cells_body(
      columns = granularity_time,
      rows = granularity_time == "isoweek (numeric)"
    )
  ) %>%
    gt::tab_footnote(
    footnote = "isoweek (character) is only used within isoyearweek.",
    locations = gt::cells_body(
      columns = granularity_time,
      rows = granularity_time == "isoweek (character)"
    )
  ) %>%
  gt::tab_footnote(
    footnote = "isoyear (numeric) is used when it is a standalone variable.",
    locations = gt::cells_body(
      columns = granularity_time,
      rows = granularity_time == "isoyear (numeric)"
    )
  ) %>%
    gt::tab_footnote(
    footnote = "isoyear (character) is only used within isoyearweek.",
    locations = gt::cells_body(
      columns = granularity_time,
      rows = granularity_time == "isoyear (character)"
    )
  ) %>%
    gt::tab_footnote(
    footnote = "If the event is ongoing, then the 'to' date should be 9999_99_99.",
    locations = gt::cells_body(
      columns = granularity_time,
      rows = stringr::str_detect(granularity_time, "event")
    )
  )
```

## Location

Locations can be obtained from [spldata](/spldata). Valid locations (and location types) are available in `spldata::norway_locations_names()`.

```{r echo=FALSE, results='asis'}
d <- spldata::norway_locations_names()[,.(
  n=.N, 
  location_code = location_code[1],
  location_name = location_name[1],
  location_name_description_nb = location_name_description_nb[1],
  location_name_file_nb_utf = location_name_file_nb_utf[1],
  location_name_file_nb_ascii = location_name_file_nb_ascii[1]
  ),
  by=.(granularity_geo)
  ]

gt::gt(d) %>%
  gt::tab_options(
    table.width = "1500px"
  ) %>%
  gt::tab_header(title = "Valid locations and location types in the splverse format") %>%
  gt::cols_label(
    granularity_geo = "Geo (Granularity)",
    n = "N"
  ) %>%
  # gt::cols_width(
  #   granularity_time ~ "20%",
  #   class ~ "15%",
  #   fn ~ "20%",
  #   example ~ "55%"
  # ) %>%
  gt::tab_spanner(
    label = "Examples",
    columns = c(location_code, location_name, location_name_description_nb, location_name_file_nb_utf, location_name_file_nb_ascii)
  ) %>%
  gt::tab_footnote(
    footnote = gt::md("**location_code**: Used a) **inside datasets** and b) in data **file names** for transfer of data/results between analytic systems. All values are unique."),
    locations = gt::cells_column_labels(
      columns = location_code
    )
  ) %>%
  gt::tab_footnote(
    footnote = gt::md("**location_name**: Used (rarely) **inside results** (figures, tables, documents). Can be confusing as some names are duplicated."),
    locations = gt::cells_column_labels(
      columns = location_name
    )
  ) %>%
  gt::tab_style(
    style = list(
      gt::cell_text(decorate = "line-through")
      ),
    locations = gt::cells_body(
      columns = location_name,
      rows = gt::everything()
    )
  ) %>%
  gt::tab_footnote(
    footnote = gt::md("**location_name_description_nb**: Used (frequently) **inside results** (figures, tables, documents). All values are unique."),
    locations = gt::cells_column_labels(
      columns = location_name_description_nb
    )
  ) %>%
  gt::tab_footnote(
    footnote = gt::md("**location_name_file_nb_utf**: Used (frequently) in the **file names** for results (figures, tables, documents). All values are unique."),
    locations = gt::cells_column_labels(
      columns = location_name_file_nb_utf
    )
  ) %>%
  gt::tab_footnote(
    footnote = gt::md("**location_name_file_nb_ascii**: Used (rarely) in the **file names** for results (figures, tables, documents). Used if file systems have problems with the Norwegian letters æøå. All values are unique."),
    locations = gt::cells_column_labels(
      columns = location_name_file_nb_ascii
    )
  ) %>%
    gt::tab_footnote(
    footnote = "Bo- og arbeidsmarkedsregioner. Housing and labor market regions.",
    locations = gt::cells_body(
      columns = granularity_geo,
      rows = granularity_geo == "baregion"
    )
  ) %>%
    gt::tab_footnote(
    footnote = "Mattilsynet-regioner. Food authority regions.",
    locations = gt::cells_body(
      columns = granularity_geo,
      rows = granularity_geo == "faregion"
    )
  ) 
```

## Location (reference)

Locations can be obtained from [spldata](/spldata). Valid locations (and location types) are available in `spldata::norway_locations_names()`.

Here we list as a reference table the valid `location_code`s and `location_name_description_nb`s (the two most commonly used locations).

```{r echo=FALSE, results='asis'}
d <- spldata::norway_locations_names()[,.(
  location_order = paste0("#", location_order),
  location_code,
  location_name_description_nb
)]

gt::gt(d) %>%
  gt::tab_options(
    table.width = "750px"
  ) %>%
  gt::tab_header(title = "Reference table of valid `location_code`s and `location_name_description_nb`s") %>%
  gt::cols_label(
    location_order = "#"
  ) 
```

## Ages

Ages should always contain 3 digits and are joined by a hyphen (e.g. `005-010`). 

Use `085p` instead of `>=085` or `85+`. 

These tips will help your data be easily sorted and kept in the right order.

Missing ages should be coded as `NA_character_`.

## Sex

Sex should be coded as strings.

```{r echo=FALSE, results='asis'}
d <- rbind(
  data.frame(
    value = "\"male\"",
    definition = "Male"
  ),
  data.frame(
    value = "\"female\"",
    definition = "Female"
  ),
  data.frame(
    value = "NA_character_",
    definition = "Missing/unknown"
  ),
  data.frame(
    value = "\"total\"",
    definition = "Everyone"
  )
)

gt::gt(d) %>%
  gt::tab_header(title = "Valid sexes in the splverse format") %>%
  gt::cols_label(
    value = "Value",
    definition = "Definition"
  )
```

## Unified variables

All accessible DB tables will contain these 16 variables.

Time conversion functions can be found in package [fhiplot](https://folkehelseinstituttet.github.io/fhiplot/articles/time_conversion.html). 

```{r echo=FALSE, results='asis'}
d <- data.frame(
  x1 = "granularity_time",
  x2 = "isoyear"
)

gt::gt(d)
```

<hr>

## Task-specific variables 

Task-specific variables are commonly referred to as Tags. A `tag` is a descriptor of the row. That is, an identifier of data that is in long format. For example: `tag_outcome, tag_exposure`.

Variable names that contain values should be in one the following forms:

- `descriptive_format`
- `descriptive_format_functiontime`

```{r echo=FALSE, results='asis'}
d <- data.frame(
  x1 = "granularity_time",
  x2 = "isoyear"
)

gt::gt(d)
```

#### Tag descriptive

When creating a database table with many different sources of data, it is recommended to include the data source as a descriptive:

- `msis_cases_testdate_n` - number of cases by testing date
- `msis_cases_regdate_n` - number of cases by registration date
- `msislab_tests_n` - number of tests performed
- `nipar_hospital_main_cause_n` - number of people who were admitted to the hospital with covid-19 as a main cause
- `nipar_icu_n` - number of people who were admitted to the ICU with covid-19
- `mor_deaths_n` - number of deaths

#### Tag format

`format` is the format that the value is stored in.

For **percentages/proportions**, we recommend using `pr100` (i.e. values going between 0 and 100) over `pr1` (i.e. values going between 0 and 1).

For **intervals**, use `XintervalY`. We recommend:

- `X` describing the type of interval. If you are using frequentist statistics, this is probably `predinterval` or `confinterval`. If you are using Bayesian statistics, then `credinterval` would be appropriate, and the `descriptive` would then determine if the credible interval is describing a variable (Bayesian prediction interval) or a population/distribution parameter (Bayesian confidence interval).
- `Y` describes the limit, for example (in percentiles) `_p02x5`, `_p97x5`, `_p00x1`, `_p99x9` or (in z-scores) `_l2`, `_u2`, `_l4`, `_u4`.

Some examples are as follows:

- `deaths_n` - number of deaths
- `deaths_n_sum0_13` - number of deaths that occurred today and the preceeding 13 days
- `deaths_pr100000_sum0_13` - number of deaths that occurred today and the preceeding 13 days, per 100 00 population
- `consultations_r80_vk_ote_n` - number of influenza consultations
- `deaths_registered_n` - number of deaths registered
- `deaths_corrected_n` - number of deaths (corrected for registration delay) 
- `deaths_corrected_n_credinterval_p02x5` - Bayesian prediction interval for the "true" number of deaths 
- `deaths_corrected_n_credinterval_p97x5` - Bayesian prediction interval for the "true" number of deaths 
- `deaths_corrected_baseline_n` - Expected number of deaths (i.e. the baseline)
- `deaths_corrected_baseline_n_credinterval_p02x5` - Bayesian prediction interval for the expected number of death (baseline)
- `deaths_corrected_baseline_n_credinterval_p97x5` - Bayesian prediction interval for the expected number of death (baseline)

#### Tag functiontime

We can also include variables that refer to multiple days/weeks:

- `msis_cases_testdate_n_sum0_13` - the aggregate number of cases for today and the preceeding 13 days by testing date
- `msis_cases_testdate_pr100000_sum0_13` - the aggregate number of cases for today and the preceeding 13 days by testing date per 100 000 population
